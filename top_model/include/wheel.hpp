#ifndef CADMIUM_WHEEL_HPP_
#define CADMIUM_WHEEL_HPP_

#include <cadmium/core/modeling/atomic.hpp>
#include <iostream>

namespace cadmium::example::Edge_robot {
	//! Class for representing the Transducer DEVS model state.
	struct wheel_state {
		double clock;        //!< Current simulation time.
		double sigma;        //!< Time to wait before triggering the next internal transition function.
		bool Edge_flag;
//		int Edge_Ctr;
		/**
		 * Transducer model state constructor function.
		 * @param obsTime total observation time before asking the Generator to stop creating new Job objects.
		 */
		wheel_state() : clock(), sigma(std::numeric_limits<double>::infinity()) {}
	};

	/**
	 * Insertion operator for TransducerState objects.
	 * @param out output stream.
	 * @param s state to be represented in the output stream.
	 * @return output stream with the state already inserted.
	 */
	std::ostream& operator<<(std::ostream &out, const wheel_state& s) {
		out << s.Edge_flag;
//		std::cout << " wheel " << std::endl;
		return out;
	}

	//! Atomic DEVS model of a Job transducer.
	class Wheel : public Atomic<wheel_state> {
	 private:
		double DrivePeriod;
	 public:
		Port<bool> In_Flag;  //!< Input Port for receiving new Job objects.
		Port<double> wheel_left_fw;
		Port<double> wheel_left_bw;
		Port<double> wheel_right_fw;
		Port<double> wheel_right_bw;
		Port<bool> wheel_right_en;
		Port<bool> wheel_left_en;
		//Port<bool> Out;

		Wheel(const std::string& id, double DrivePeriod): Atomic<wheel_state>(id, wheel_state()), DrivePeriod(DrivePeriod) {
			In_Flag = addInPort<bool>("In_Flag");
			//Out = addOutPort<bool>("out1");
			wheel_left_fw = addOutPort<double>("wheel_left_fw");
			wheel_left_bw = addOutPort<double>("wheel_left_bw");
			wheel_right_fw = addOutPort<double>("wheel_right_fw");
			wheel_right_bw = addOutPort<double>("wheel_right_bw");
			wheel_right_en = addOutPort<bool>("wheel_right_en");
			wheel_left_en = addOutPort<bool>("wheel_left_en");
		}

		/**
		 * It updates TransducerState::clock and TransducerState::sigma.
		 * As the internal transition is only triggered at the end, TransducerState::sigma is set to infinity.
		 * It also prints some simulation statistics.
		 * @param s reference to the current state of the model.
		 */
		void internalTransition(wheel_state& s) const override {
			s.clock += s.sigma;
			s.sigma = std::numeric_limits<double>::infinity(); //100; //
		}

		/**
		 * It updates TransducerState::clock and TransducerState::sigma.
		 * It also keeps track of the Job objects generated by the Generator and processed by the Processor.
		 * @param s reference to the current model state.
		 * @param e time elapsed since the last state transition function was triggered.
		 * @param x reference to the model input port set.
		 */
		void externalTransition(wheel_state& s, double e) const override {
			if (!In_Flag->empty()) {
			 	for(const auto x : In_Flag->getBag())
			 	{
			 		s.Edge_flag = In_Flag->getBag().back();
			 	}
			if(s.Edge_flag == 0)
			{
				s.sigma = DrivePeriod*3;
			}
			else
				s.sigma = DrivePeriod;
			}
		}

		/**
		 * It sends a message to the Generator to stop generating new Job objects.
		 * @param s reference to the current model state.
		 * @param y reference to the atomic model output port set.
		 */
		void output(const wheel_state& s) const override {
			wheel_right_en ->addMessage (true);
			wheel_left_en ->addMessage (true);
			if((s.Edge_flag == 0)) //||(s.Edge_Ctr<5)
			{
				wheel_left_fw ->addMessage(double(0));
				wheel_left_bw ->addMessage(double(0.25));
				wheel_right_fw ->addMessage(double(0));
				wheel_right_bw ->addMessage(double(0.25));
				std::cout << "motion backward  " << std::endl;
				
			}
			else
			{
				wheel_left_fw ->addMessage(double(0.25));
				wheel_left_bw ->addMessage(double(0));
				wheel_right_fw ->addMessage(double(0.65));
				wheel_right_bw ->addMessage(double(0));	
				std::cout << "motion forward  " << std::endl;
//				std::cout << "motion forward  " << std::endl;			
			}
			//Out->addMessage(s.start_stop_input);
//			std::cout << " Output "<< std::endl;
		}

		/**
		 * It returns the value of TransducerState::sigma.
		 * @param s reference to the current model state.
		 * @return the sigma value.
		 */
		[[nodiscard]] double timeAdvance(const wheel_state& s) const override {
			return s.sigma;
		}
	};
}  //namespace cadmium::example::cleaning_robot

#endif //CADMIUM_WHEEL_HPP_
